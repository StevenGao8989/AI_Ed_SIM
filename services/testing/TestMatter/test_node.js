/**
 * ÊñúÂù°Á¢∞ÊíûÂä®ÁîªÁ§∫‰æã - Node.jsÁâàÊú¨ + ËßÜÈ¢ëÁîüÊàê
 * È¢òÁõÆÔºöÂú®ÊñúÂù°‰∏äÊñπÈ°∂Á´ØÊîæ‰∏Ä‰∏™Ë¥®Èáèm = 0.5kgÁêÉÔºåÂù°Â∫¶‰∏∫30Â∫¶ÔºåÈïø5ÂéòÁ±≥Ôºå
 * Âè¶‰∏Ä‰∏™Ë¥®Èáè‰∏∫M = 1kgÁöÑÂ∞èÁêÉÁ¶ªÊñúÂù°5ÂéòÁ±≥„ÄÇÊ∞¥Âπ≥Èù¢‰∏∫Á≤óÁ≥ôÊ∞¥Âπ≥Èù¢ÔºåÂä®Êë©Êì¶Âõ†Êï∞Œº=0.25Ôºå
 * ËÆ°ÁÆóÁ¢∞ÊíûÂêéÁ¨¨‰∫å‰∏™ÁêÉÁöÑÈÄüÂ∫¶„ÄÇ
 */

const Matter = require('matter-js');
const fs = require('fs');
const path = require('path');
const { createCanvas } = require('canvas');

class RampCollisionTestWithVideo {
  constructor(options = {}) {
    this.options = {
      width: options.width || 1000,
      height: options.height || 600,
      fps: options.fps || 30,
      duration: options.duration || 10,
      outputDir: options.outputDir || path.join(__dirname, 'output'),
      ...options
    };
    
    this.ensureOutputDir();
    this.setupEngine();
    this.createPhysicsWorld();
    this.setupEventListeners();
  }

  ensureOutputDir() {
    if (!fs.existsSync(this.options.outputDir)) {
      fs.mkdirSync(this.options.outputDir, { recursive: true });
    }
  }

  setupEngine() {
    // ÂàõÂª∫ÂºïÊìé
    this.engine = Matter.Engine.create();
    this.world = this.engine.world;
    
    // ËÆæÁΩÆÈáçÂäõ
    this.engine.world.gravity.y = 9.8; // Ê†áÂáÜÈáçÂäõÂä†ÈÄüÂ∫¶
    
    // ÂàõÂª∫Canvas
    this.canvas = createCanvas(this.options.width, this.options.height);
    this.ctx = this.canvas.getContext('2d');
    
    console.log('‚úÖ Matter.jsÂºïÊìéÂàùÂßãÂåñÂÆåÊàê');
  }

  createPhysicsWorld() {
    // Áâ©ÁêÜÂèÇÊï∞
    const rampAngle = Math.PI / 6; // 30Â∫¶ = œÄ/6 ÂºßÂ∫¶
    const rampLength = 250; // ÊñúÂù°ÈïøÂ∫¶ (ÂÉèÁ¥†) - Âª∂ÈïøËá≥400ÂÉèÁ¥†
    const ball1Mass = 0.5; // Â∞èÁêÉË¥®Èáè
    const ball2Mass = 1.0; // Â§ßÁêÉË¥®Èáè
    const friction = 0.25; // Âä®Êë©Êì¶Âõ†Êï∞

    // Âú∞Èù¢‰ΩçÁΩÆ - Âª∂ÈïøËá≥ÁîªÂ∏ÉËæπÁïå
    const groundY = 550;
    const groundWidth = this.options.width; // ‰ΩøÁî®ÁîªÂ∏ÉÂÆΩÂ∫¶
    const groundX = this.options.width / 2; // Âú∞Èù¢‰∏≠ÂøÉXÂùêÊ†á

    // ÈáçÊñ∞ËÆ°ÁÆóÊñúÂù°‰ΩçÁΩÆÔºå‰ΩøÂè≥Á´Ø‰∏éÂú∞Èù¢Êé•Ëß¶
    const rampWidth = 20;
    
    // ÊñúÂù°Âè≥Á´ØÁÇπ‰ΩçÁΩÆÔºà‰∏éÂú∞Èù¢Êé•Ëß¶Ôºâ
    const rampRightX = groundX - 150; // ÊñúÂù°Âè≥Á´ØË∑ùÁ¶ªÁîªÂ∏É‰∏≠ÂøÉ150ÂÉèÁ¥†
    const rampRightY = groundY - 10; // ÊñúÂù°Âè≥Á´ØÂú®Âú∞Èù¢‰∏äÊñπ10ÂÉèÁ¥†
    
    // ËÆ°ÁÆóÊñúÂù°‰∏≠ÂøÉ‰ΩçÁΩÆ
    const rampX = rampRightX - (rampLength / 2) * Math.cos(rampAngle);
    const rampY = rampRightY - (rampLength / 2) * Math.sin(rampAngle);

    // ÂàõÂª∫ÊñúÂù° (ÈùôÊÄÅÁü©ÂΩ¢)
    this.ramp = Matter.Bodies.rectangle(rampX, rampY, rampLength, rampWidth, {
      isStatic: true,
      angle: rampAngle,
      render: {
        fillStyle: '#8B4513',
        strokeStyle: '#654321',
        lineWidth: 2
      }
    });

    // ÂàõÂª∫Á≤óÁ≥ôÊ∞¥Âπ≥Èù¢ (ÈùôÊÄÅÁü©ÂΩ¢)
    this.ground = Matter.Bodies.rectangle(groundX, groundY, groundWidth, 20, {
      isStatic: true,
      friction: friction,
      frictionStatic: friction,
      render: {
        fillStyle: '#666666',
        strokeStyle: '#333333',
        lineWidth: 2
      }
    });

    // ËÆ°ÁÆóÂ∞èÁêÉÂàùÂßã‰ΩçÁΩÆ (ÊñúÂù°È°∂Á´Ø)
    const ball1Radius = 15;
    this.ball1X = rampX - (rampLength / 2) * Math.cos(rampAngle) + ball1Radius * Math.sin(rampAngle);
    this.ball1Y = rampY - (rampLength / 2) * Math.sin(rampAngle) - ball1Radius * Math.cos(rampAngle);

    // ÂàõÂª∫Â∞èÁêÉ (m = 0.5kg)
    this.ball1 = Matter.Bodies.circle(this.ball1X, this.ball1Y, ball1Radius, {
      mass: ball1Mass,
      friction: 0.1,
      frictionStatic: 0.1,
      restitution: 0.3,
      render: {
        fillStyle: '#FF6B6B',
        strokeStyle: '#CC5555',
        lineWidth: 2
      }
    });

    // ËÆ°ÁÆóÂ§ßÁêÉÂàùÂßã‰ΩçÁΩÆ (Á¶ªÊñúÂù°Âè≥Á´Ø5ÂéòÁ±≥ÔºåËΩ¨Êç¢‰∏∫ÂÉèÁ¥†Á∫¶50ÂÉèÁ¥†)
    const ball2Radius = 20;
    this.ball2X = rampRightX + 100; // ÊñúÂù°Âè≥Á´ØÂêëÂè≥50ÂÉèÁ¥†
    this.ball2Y = rampRightY - ball2Radius; // Âú®Âú∞Èù¢‰∏äÊñπ

    // ÂàõÂª∫Â§ßÁêÉ (M = 1kg)
    this.ball2 = Matter.Bodies.circle(this.ball2X, this.ball2Y, ball2Radius, {
      mass: ball2Mass,
      friction: friction,
      frictionStatic: friction,
      restitution: 0.3,
      render: {
        fillStyle: '#4ECDC4',
        strokeStyle: '#3BA39C',
        lineWidth: 2
      }
    });

    // Ê∑ªÂä†ÊâÄÊúâÁâ©‰ΩìÂà∞‰∏ñÁïå
    Matter.Composite.add(this.world, [this.ramp, this.ground, this.ball1, this.ball2]);

    console.log('‚úÖ Áâ©ÁêÜ‰∏ñÁïåÂàõÂª∫ÂÆåÊàê');
    console.log(`   - ÊñúÂù°ËßíÂ∫¶: ${(rampAngle * 180 / Math.PI).toFixed(1)}¬∞`);
    console.log(`   - Â∞èÁêÉË¥®Èáè: ${ball1Mass}kg`);
    console.log(`   - Â§ßÁêÉË¥®Èáè: ${ball2Mass}kg`);
    console.log(`   - Êë©Êì¶Âõ†Êï∞: ${friction}`);
  }

  setupEventListeners() {
    // Ê∑ªÂä†Á¢∞Êíû‰∫ã‰ª∂ÁõëÂê¨Âô®
    Matter.Events.on(this.engine, 'collisionStart', (event) => {
      const pairs = event.pairs;

      for (let i = 0; i < pairs.length; i++) {
        const pair = pairs[i];
        const bodyA = pair.bodyA;
        const bodyB = pair.bodyB;

        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ∞èÁêÉÂíåÂ§ßÁêÉÁöÑÁ¢∞Êíû
        if ((bodyA === this.ball1 && bodyB === this.ball2) || (bodyA === this.ball2 && bodyB === this.ball1)) {
          console.log('üéØ ÁêÉ‰ΩìÁ¢∞ÊíûÂèëÁîüÔºÅ');
          
          const v1 = bodyA === this.ball1 ? bodyA.velocity : bodyB.velocity;
          const v2 = bodyA === this.ball2 ? bodyA.velocity : bodyB.velocity;
          
          const speed1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
          const speed2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
          
          console.log(`   Â∞èÁêÉÈÄüÂ∫¶: ${speed1.toFixed(2)} m/s`);
          console.log(`   Â§ßÁêÉÈÄüÂ∫¶: ${speed2.toFixed(2)} m/s`);

          // ËÆ°ÁÆóÁ¢∞ÊíûÂêéÁöÑÈÄüÂ∫¶ (ÁÆÄÂåñÁöÑÂºπÊÄßÁ¢∞Êíû)
          const ball1Mass = 0.5;
          const ball2Mass = 1.0;
          const totalMass = ball1Mass + ball2Mass;
          
          const v1New = {
            x: (v1.x * (ball1Mass - ball2Mass) + 2 * ball2Mass * v2.x) / totalMass,
            y: (v1.y * (ball1Mass - ball2Mass) + 2 * ball2Mass * v2.y) / totalMass
          };
          const v2New = {
            x: (v2.x * (ball2Mass - ball1Mass) + 2 * ball1Mass * v1.x) / totalMass,
            y: (v2.y * (ball2Mass - ball1Mass) + 2 * ball1Mass * v1.y) / totalMass
          };

          const speed1New = Math.sqrt(v1New.x * v1New.x + v1New.y * v1New.y);
          const speed2New = Math.sqrt(v2New.x * v2New.x + v2New.y * v2New.y);

          console.log(`   Á¢∞ÊíûÂêéÂ∞èÁêÉÈÄüÂ∫¶: ${speed1New.toFixed(2)} m/s`);
          console.log(`   Á¢∞ÊíûÂêéÂ§ßÁêÉÈÄüÂ∫¶: ${speed2New.toFixed(2)} m/s`);
          
          // Â∫îÁî®Á¢∞ÊíûÂêéÁöÑÈÄüÂ∫¶Âà∞ÁêÉ‰Ωì
          Matter.Body.setVelocity(this.ball1, v1New);
          Matter.Body.setVelocity(this.ball2, v2New);
        }
      }
    });

    console.log('‚úÖ ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆÂÆåÊàê');
  }

  renderFrame(frameNumber) {
    // Ê∏ÖÁ©∫ÁîªÂ∏É
    this.ctx.fillStyle = '#f0f0f0';
    this.ctx.fillRect(0, 0, this.options.width, this.options.height);

    // ÁªòÂà∂ÊñúÂù°
    this.ctx.save();
    this.ctx.translate(this.ramp.position.x, this.ramp.position.y);
    this.ctx.rotate(this.ramp.angle);
    this.ctx.fillStyle = '#8B4513';
    this.ctx.strokeStyle = '#654321';
    this.ctx.lineWidth = 2;
    // ‰ΩøÁî®ÊñúÂù°ÁöÑÂÆûÈôÖÈïøÂ∫¶ÂíåÂÆΩÂ∫¶
    const rampLength = 250; // ‰∏éÁâ©ÁêÜ‰∏ñÁïå‰øùÊåÅ‰∏ÄËá¥
    const rampWidth = 20;
    this.ctx.fillRect(-rampLength/2, -rampWidth/2, rampLength, rampWidth);
    this.ctx.strokeRect(-rampLength/2, -rampWidth/2, rampLength, rampWidth);
    this.ctx.restore();

    // ÁªòÂà∂Âú∞Èù¢ - Âª∂ÈïøËá≥ÁîªÂ∏ÉËæπÁïå
    this.ctx.fillStyle = '#666666';
    this.ctx.strokeStyle = '#333333';
    this.ctx.lineWidth = 2;
    this.ctx.fillRect(0, 540, this.options.width, 20);
    this.ctx.strokeRect(0, 540, this.options.width, 20);

    // ÁªòÂà∂Â∞èÁêÉ
    this.ctx.fillStyle = '#FF6B6B';
    this.ctx.strokeStyle = '#CC5555';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.arc(this.ball1.position.x, this.ball1.position.y, 15, 0, 2 * Math.PI);
    this.ctx.fill();
    this.ctx.stroke();

    // ÁªòÂà∂Â§ßÁêÉ
    this.ctx.fillStyle = '#4ECDC4';
    this.ctx.strokeStyle = '#3BA39C';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.arc(this.ball2.position.x, this.ball2.position.y, 20, 0, 2 * Math.PI);
    this.ctx.fill();
    this.ctx.stroke();

    // ÁªòÂà∂ÈÄüÂ∫¶Áü¢Èáè
    this.drawVelocityVector(this.ball1, '#FF6B6B');
    this.drawVelocityVector(this.ball2, '#4ECDC4');

    // ÁªòÂà∂‰ø°ÊÅØ
    this.drawInfo(frameNumber);
  }

  drawVelocityVector(body, color) {
    const scale = 10; // ÈÄüÂ∫¶Áü¢ÈáèÁº©Êîæ
    const vx = body.velocity.x * scale;
    const vy = body.velocity.y * scale;
    
    if (Math.abs(vx) > 1 || Math.abs(vy) > 1) {
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.moveTo(body.position.x, body.position.y);
      this.ctx.lineTo(body.position.x + vx, body.position.y + vy);
      this.ctx.stroke();
      
      // ÁªòÂà∂ÁÆ≠Â§¥
      const angle = Math.atan2(vy, vx);
      const arrowLength = 8;
      this.ctx.beginPath();
      this.ctx.moveTo(body.position.x + vx, body.position.y + vy);
      this.ctx.lineTo(
        body.position.x + vx - arrowLength * Math.cos(angle - Math.PI / 6),
        body.position.y + vy - arrowLength * Math.sin(angle - Math.PI / 6)
      );
      this.ctx.moveTo(body.position.x + vx, body.position.y + vy);
      this.ctx.lineTo(
        body.position.x + vx - arrowLength * Math.cos(angle + Math.PI / 6),
        body.position.y + vy - arrowLength * Math.sin(angle + Math.PI / 6)
      );
      this.ctx.stroke();
    }
  }

  drawInfo(frameNumber) {
    this.ctx.fillStyle = '#000000';
    this.ctx.font = '16px Arial';
    
    // ËÆ°ÁÆóÈÄüÂ∫¶
    const ball1Speed = Math.sqrt(this.ball1.velocity.x ** 2 + this.ball1.velocity.y ** 2);
    const ball2Speed = Math.sqrt(this.ball2.velocity.x ** 2 + this.ball2.velocity.y ** 2);
    
    // ÁªòÂà∂‰ø°ÊÅØ
    this.ctx.fillText(`Êó∂Èó¥: ${(frameNumber / this.options.fps).toFixed(2)}s`, 20, 30);
    this.ctx.fillText(`Â∞èÁêÉÈÄüÂ∫¶: ${ball1Speed.toFixed(2)} m/s`, 20, 50);
    this.ctx.fillText(`Â§ßÁêÉÈÄüÂ∫¶: ${ball2Speed.toFixed(2)} m/s`, 20, 70);
    this.ctx.fillText(`Â∏ßÊï∞: ${frameNumber}`, 20, 90);
    
    // ÁªòÂà∂Áâ©ÁêÜÂèÇÊï∞
    this.ctx.fillText('ÊñúÂù°ËßíÂ∫¶: 30¬∞', 20, 120);
    this.ctx.fillText('Â∞èÁêÉË¥®Èáè: 0.5kg', 20, 140);
    this.ctx.fillText('Â§ßÁêÉË¥®Èáè: 1.0kg', 20, 160);
    this.ctx.fillText('Êë©Êì¶Âõ†Êï∞: 0.25', 20, 180);
  }

  resetSimulation() {
    // ÈáçÁΩÆÂ∞èÁêÉ‰ΩçÁΩÆ
    Matter.Body.setPosition(this.ball1, { x: this.ball1X, y: this.ball1Y });
    Matter.Body.setVelocity(this.ball1, { x: 0, y: 0 });
    Matter.Body.setAngle(this.ball1, 0);
    Matter.Body.setAngularVelocity(this.ball1, 0);

    // ÈáçÁΩÆÂ§ßÁêÉ‰ΩçÁΩÆ
    Matter.Body.setPosition(this.ball2, { x: this.ball2X, y: this.ball2Y });
    Matter.Body.setVelocity(this.ball2, { x: 0, y: 0 });
    Matter.Body.setAngle(this.ball2, 0);
    Matter.Body.setAngularVelocity(this.ball2, 0);

    console.log('üîÑ ‰ªøÁúüÂ∑≤ÈáçÁΩÆ');
  }

  async generateVideo() {
    try {
      console.log('üé¨ ÂºÄÂßãÁîüÊàêÊñúÂù°Á¢∞ÊíûËßÜÈ¢ë');
      console.log('='.repeat(50));

      const totalFrames = this.options.duration * this.options.fps;
      const frameDir = path.join(this.options.outputDir, 'temp_frames');
      
      // ÂàõÂª∫‰∏¥Êó∂Â∏ßÁõÆÂΩï
      if (!fs.existsSync(frameDir)) {
        fs.mkdirSync(frameDir, { recursive: true });
      }

      // ÈáçÁΩÆ‰ªøÁúü
      this.resetSimulation();

      // ÁîüÊàêÂ∏ß
      console.log('üì∏ ÂºÄÂßãÁîüÊàêÂ∏ß...');
      for (let frame = 0; frame < totalFrames; frame++) {
        // Êõ¥Êñ∞Áâ©ÁêÜÂºïÊìé
        Matter.Engine.update(this.engine, 1000 / this.options.fps);
        
        // Ê∏≤ÊüìÂ∏ß
        this.renderFrame(frame);
        
        // ‰øùÂ≠òÂ∏ß
        const framePath = path.join(frameDir, `frame_${frame.toString().padStart(6, '0')}.png`);
        const buffer = this.canvas.toBuffer('image/png');
        fs.writeFileSync(framePath, buffer);
        
        // ÊòæÁ§∫ËøõÂ∫¶
        if (frame % 30 === 0) {
          console.log(`   üì∏ ÁîüÊàêÂ∏ß: ${frame + 1}/${totalFrames}`);
        }
      }

      console.log('‚úÖ Â∏ßÁîüÊàêÂÆåÊàê');

      // ‰ΩøÁî®ffmpegÂêàÊàêËßÜÈ¢ë
      const { exec } = require('child_process');
      const util = require('util');
      const execAsync = util.promisify(exec);

      const outputPath = path.join(this.options.outputDir, 'ramp_collision_test.mp4');
      
      console.log('üé¨ ÂºÄÂßãËßÜÈ¢ëÂêàÊàê...');
      const ffmpegCommand = `ffmpeg -y -framerate ${this.options.fps} -i "${frameDir}/frame_%06d.png" -c:v libx264 -pix_fmt yuv420p -crf 23 "${outputPath}"`;
      
      try {
        const { stdout, stderr } = await execAsync(ffmpegCommand);
        console.log('‚úÖ ËßÜÈ¢ëÂêàÊàêÂÆåÊàê');
      } catch (error) {
        throw new Error(`FFmpegÈîôËØØ: ${error.message}`);
      }

      // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
      console.log('üßπ Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂...');
      const files = fs.readdirSync(frameDir);
      for (const file of files) {
        fs.unlinkSync(path.join(frameDir, file));
      }
      fs.rmdirSync(frameDir);

      // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
      const stats = fs.statSync(outputPath);
      const fileSizeMB = (stats.size / 1024 / 1024).toFixed(2);

      console.log('‚úÖ ËßÜÈ¢ëÁîüÊàêÊàêÂäü');
      console.log(`   - ËßÜÈ¢ëË∑ØÂæÑ: ${outputPath}`);
      console.log(`   - ÊÄªÂ∏ßÊï∞: ${totalFrames}`);
      console.log(`   - Êó∂Èïø: ${this.options.duration}s`);
      console.log(`   - ÂàÜËæ®Áéá: ${this.options.width}x${this.options.height}`);
      console.log(`   - Â∏ßÁéá: ${this.options.fps}fps`);
      console.log(`   - Êñá‰ª∂Â§ßÂ∞è: ${fileSizeMB}MB`);

      return {
        success: true,
        outputPath,
        stats: {
          totalFrames,
          duration: this.options.duration,
          resolution: `${this.options.width}x${this.options.height}`,
          fps: this.options.fps,
          fileSize: stats.size
        }
      };

    } catch (error) {
      console.error('‚ùå ËßÜÈ¢ëÁîüÊàêÂ§±Ë¥•:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  runSimulation(duration = 5) {
    console.log(`üöÄ ÂºÄÂßãËøêË°å‰ªøÁúü (${duration}Áßí)`);
    console.log('='.repeat(50));

    const startTime = Date.now();
    const endTime = startTime + duration * 1000;
    let frameCount = 0;

    const runFrame = () => {
      const currentTime = Date.now();
      
      if (currentTime >= endTime) {
        console.log('‚úÖ ‰ªøÁúüÂÆåÊàê');
        console.log(`   - ÊÄªÂ∏ßÊï∞: ${frameCount}`);
        console.log(`   - ËøêË°åÊó∂Èó¥: ${((currentTime - startTime) / 1000).toFixed(2)}s`);
        
        const ball1Speed = Math.sqrt(this.ball1.velocity.x ** 2 + this.ball1.velocity.y ** 2);
        const ball2Speed = Math.sqrt(this.ball2.velocity.x ** 2 + this.ball2.velocity.y ** 2);
        
        console.log(`   - ÊúÄÁªàÂ∞èÁêÉÈÄüÂ∫¶: ${ball1Speed.toFixed(2)} m/s`);
        console.log(`   - ÊúÄÁªàÂ§ßÁêÉÈÄüÂ∫¶: ${ball2Speed.toFixed(2)} m/s`);
        
        return;
      }

      // Êõ¥Êñ∞Áâ©ÁêÜÂºïÊìé
      Matter.Engine.update(this.engine, 16.67); // 60fps
      frameCount++;

      // ÊØè100Â∏ßÊòæÁ§∫‰∏ÄÊ¨°Áä∂ÊÄÅ
      if (frameCount % 100 === 0) {
        const ball1Speed = Math.sqrt(this.ball1.velocity.x ** 2 + this.ball1.velocity.y ** 2);
        const ball2Speed = Math.sqrt(this.ball2.velocity.x ** 2 + this.ball2.velocity.y ** 2);
        const elapsed = (currentTime - startTime) / 1000;
        console.log(`   üìä Êó∂Èó¥: ${elapsed.toFixed(1)}s, Â∞èÁêÉÈÄüÂ∫¶: ${ball1Speed.toFixed(2)} m/s, Â§ßÁêÉÈÄüÂ∫¶: ${ball2Speed.toFixed(2)} m/s`);
      }

      // ÁªßÁª≠‰∏ã‰∏ÄÂ∏ß
      setImmediate(runFrame);
    };

    runFrame();
  }
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§Êñá‰ª∂
if (require.main === module) {
  console.log('üéÆ ÊñúÂù°Á¢∞ÊíûÁâ©ÁêÜ‰ªøÁúüÊµãËØï + ËßÜÈ¢ëÁîüÊàê');
  console.log('='.repeat(50));
  
  const test = new RampCollisionTestWithVideo({
    width: 1000,
    height: 600,
    fps: 30,
    duration: 10
  });
  
  // ËøêË°å‰ªøÁúüÂπ∂ÁîüÊàêËßÜÈ¢ë
  test.generateVideo().then(result => {
    if (result.success) {
      console.log('\nüéâ ÊµãËØïÂÆåÊàêÔºÅËßÜÈ¢ëÂ∑≤ÁîüÊàê„ÄÇ');
    } else {
      console.log('\n‚ùå ÊµãËØïÂ§±Ë¥•:', result.error);
    }
  }).catch(console.error);
}

module.exports = RampCollisionTestWithVideo;
